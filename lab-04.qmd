---
title: "lab-04"
subtitle: 'Rasters and Remote Sensing'
author:
  - name: Matthew Woodworth
    email: mattwood@colostate.edu
format:
  html:
    code-fold: true
    toc: true
    include-before-body: ../slides/header.html
    include-after-body:  ../slides/footer-annotations.html
---

Background

On September 26, 2016 at 11:47 a.m. U.S. Central Daylight Time (16:47 UTC) the Cedar and Wapsipinicon rivers in Iowa surged producing a flood wave that breached the river banks. The water level of the Cedar River measured ~20 feet — 8 feet above flood stage—near the city of Cedar Rapids.

The water level continued to rise until it peaked at ~22 feet on September 27. This event had only been exceeded once, in June 2008, when thousands of people were encouraged to evacuate from Cedar Rapids, the second-most-populous city in Iowa.

In this lab we are interested in the impacts in Palo Iowa because it is up stream of Cedar Rapids, contains a large amount of farm land, and does not have a forecast location to provide warning.

We will use the terra and rstac packages - along with our understanding of raster data and categorization - to create flood images using mutliband Landsat Imagery, thresholding, and classification methods.


# Libraries
```{r}

library(rstac) # STAC API
library(terra) # Raster Data handling
library(sf) # Vector data processing
library(mapview) # Rapid Interactive visualization
```

## Step 1: AOI identification

First we need to identify an AOI. We want to be able to extract the flood extents for Palo, Iowa and its surroundings. To do this we will use the geocoding capabilities within the AOI package.
```{r}
palo <- AOI::geocode("Palo, Iowa", bbox = TRUE)
```

## Step 2: Temporal identification

The flood event occurred on September 26, 2016. A primary challenge with remote sensing is the fact that all satellite imagery is not available at all times. In this case Landsat 8 has an 8 day revisit time. To ensure we capture an image within the date of the flood, lets set our time range to the period between September 24th - 29th of 2016. We will define this duration in the form YYYY-MM-DD/YYYY-MM-DD.
```{r}
temporal_range <- "2016-09-24/2016-09-29"
```

Step 3: Identifying the relevant images

The next step is to identify the images that are available for our AOI and time range. This is where the rstac package comes in. The rstac package provides a simple interface to the SpatioTemporal Asset Catalog (STAC) API, which is a standard for discovering and accessing geospatial data.

STAC is a specification for describing geospatial data in a consistent way, making it easier to discover and access datasets. It provides a standardized way to describe the metadata of geospatial assets, including their spatial and temporal extents, data formats, and other relevant information.

Catalog: A catalog is a collection of STAC items and collections. It serves as a top-level container for organizing and managing geospatial data. A catalog can contain multiple collections, each representing a specific dataset or group of related datasets.

Items: The basic unit of data in STAC. Each item represents a single asset, such as a satellite image or a vector dataset. Items contain metadata that describes the asset, including its spatial and temporal extents, data format, and other relevant information.

Asset: An asset is a specific file or data product associated with an item. For example, a single satellite image may have multiple assets, such as different bands or processing levels. Assets are typically stored in a cloud storage system and can be accessed via URLs.

For this project we are going to use a STAC catalog to identify the data available for our analysis. We want data from the Landsat 8 collection which is served by the USGS (via AWS), Google, and Microsoft Planetary Computer (MPC). MPC is the one that provides free access so we will use that data store.

If you go to this link you see the JSON representation of the full data holdings. If you CMD/CTL+F on that page for Landsat you’ll find the references for the available data stores.

Within R, we can open a connection to this endpoint with the stac function:

```{r}
# Open a connection to the MPC STAC API
(stac_query <- stac("https://planetarycomputer.microsoft.com/api/stac/v1"))
```

That connection will provide an open entry to ALL data hosted by MPC. The stac_search function allows us to reduce the catalog to assets that match certain criteria (just like dplyr::filter reduces a data.frame). The get_request() function sends your search to the STAC API returning the metadata about the objects that match a criteria. The service implementation at MPC sets a return limit of 250 items (but it could be overridden with the limit parameter).

Here, we are interested in the “Landsat Collection 2 Level-2” data. From the JSON file (seen in the browser). To start, lets search for that collection using the stac -> stac_search –> get_request workflow:

```{r}
(stac_query <-stac("https://planetarycomputer.microsoft.com/api/stac/v1") %>%  
  stac_search(
    collections = "landsat-c2-l2") %>% 
  get_request())
```

Awesome! So the first 250 items from the Level-2 Landsat collection were returned. Within each item, there are a number of assets (e.g. the red, green, blue bands) and all items have some associated fields like the sub item assets, the bounding box, etc. We can now refine our search to limit the returned results to those that cover our AOI and time range of interest:

```{r}
(stac_query <- stac("https://planetarycomputer.microsoft.com/api/stac/v1") %>%  
  stac_search(
    collections = "landsat-c2-l2",
    datetime    = temporal_range,
    bbox        = st_bbox(palo)) %>% 
  get_request())
```

By adding these constraints, we now see just two items. One from the Landsat 7 Level 2 dataset, and one from the Landsat 8 Level 2 dataset. For this lab, lets focus on the Landsat 8 item. We can use either the item or the id search criteria to elect this:

```{r}
(stac_query <- stac("https://planetarycomputer.microsoft.com/api/stac/v1") %>%  
  stac_search(
    collections = "landsat-c2-l2",
    datetime    = temporal_range,
    bbox        = st_bbox(palo),
    limit = 1) %>% 
  get_request())
```

The last thing we need to do, is sign this request. In rstac, items_sign(sign_planetary_computer()) signs STAC item asset URLs retrieved from Microsoft’s Planetary Computer, ensuring they include authentication tokens for access. sign_planetary_computer() generates the necessary signing function, and items_sign() applies it to STAC items. This is essential for accessing datasets hosted on the Planetary Computer, and other catalog were data access might be requester-paid or limited.

```{r}
(stac_query <- stac("https://planetarycomputer.microsoft.com/api/stac/v1") %>%  
  stac_search(
    collections = "landsat-c2-l2",
    datetime    = temporal_range,
    bbox        = st_bbox(palo),
    limit = 1) %>%  
  get_request() %>% 
  items_sign(sign_planetary_computer()))
```

## Step 4: Downloading needed images

OK! Now that we have identified the item we want, we are ready to download the data using assets_download(). In total, a Landsat 8 item has the following 11 bands:

For this lab, lets just get the first 6 bands. Assets are extracted from a STAC item by the asset name (look at the print statements of the stac_query). Let’s define a vector of the assets we want:

```{r}
# Bands 1-6
bands <- c('coastal', 'blue', 'green', 'red', 'nir08', 'swir16')
```

Now we can use the assets_download() function to download the data. The output_dir argument specifies where to save the files, and the overwrite argument specifies whether to overwrite existing files with the same name.

```{r}
assets_download(items = stac_query,
                asset_names = bands, 
                output_dir = "~/Desktop/CSU Spring 2025/ESS523c/ESS_523c", 
                overwrite = TRUE)
```

And that does it! You now have the process needed to get you data.

With a set of local files, you can create a raster object! Remember your files need to be in the order of the bands (double check step 2).

list.files() can search a directory for a pattern and return a list of files. The recursive argument will search all sub-directories. The full.names argument will return the full path to the files.

The rast() function will read the files into a raster object.

The setNames() function will set the names of the bands to the names we defined above.

# Question 1: Data Access

Download all the data needed for this lab. What are the dimensions of your stacked image? What is the CRS? What is the cell resolution?

### The dimensions are 7801 by 7681 with 6 layers for the 6 bands downloaded. The CRS for this object is the WGS 84 UTM zone 15N (EPSG: 32615). This raster object has a resolution of 30m by 30m for each cell.

```{r}
files <- list.files(path = "~/Desktop/CSU Spring 2025/ESS523c/ESS_523c", 
                    pattern = ".TIF$", recursive = TRUE, full.names = TRUE)
flood_raster <- rast(files)
names(flood_raster) <- bands


flood_raster
```

## Step 5: Analyize the images

We only want to analyze our image for the regions surrounding Palo (our AOI). Transform your AOI to the CRS of the landsat stack and use it to crop your raster stack.

Awesome! We have now (1) identified, (2) downloaded, and (3) saved our images.

We have loaded them as a multiband SpatRast object and cropped the domain to our AOI. Lets make a few RGB plots to see what these images reveal.

```{r}

```

